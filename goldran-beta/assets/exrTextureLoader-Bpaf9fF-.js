import{C as yn,L as Sn,d as G}from"./Screen-Bl-8DfGB.js";const ln=4,X=4,an=1,R=2,xn=8,H=65536,j=H>>3,En=16,T=14,L=(1<<En)+1,V=1<<T,d=V-1,q=59,sn=63,vn=2+sn-q;var U;(function(n){n[n.NO_COMPRESSION=0]="NO_COMPRESSION",n[n.RLE_COMPRESSION=1]="RLE_COMPRESSION",n[n.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",n[n.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",n[n.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",n[n.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"})(U||(U={}));var K;(function(n){n[n.INCREASING_Y=0]="INCREASING_Y",n[n.DECREASING_Y=1]="DECREASING_Y"})(K||(K={}));const z=bn();function bn(){const n=new ArrayBuffer(4),t=new Float32Array(n),e=new Uint32Array(n),l=new Uint32Array(512),r=new Uint32Array(512);for(let a=0;a<256;++a){const s=a-127;s<-27?(l[a]=0,l[a|256]=32768,r[a]=24,r[a|256]=24):s<-14?(l[a]=1024>>-s-14,l[a|256]=1024>>-s-14|32768,r[a]=-s-1,r[a|256]=-s-1):s<=15?(l[a]=s+15<<10,l[a|256]=s+15<<10|32768,r[a]=13,r[a|256]=13):s<128?(l[a]=31744,l[a|256]=64512,r[a]=24,r[a|256]=24):(l[a]=31744,l[a|256]=64512,r[a]=13,r[a|256]=13)}const c=new Uint32Array(2048),i=new Uint32Array(64),o=new Uint32Array(64);for(let a=1;a<1024;++a){let s=a<<13,u=0;for(;!(s&8388608);)s<<=1,u-=8388608;s&=-8388609,u+=947912704,c[a]=s|u}for(let a=1024;a<2048;++a)c[a]=939524096+(a-1024<<13);for(let a=1;a<31;++a)i[a]=a<<23;i[31]=1199570944,i[32]=2147483648;for(let a=33;a<63;++a)i[a]=2147483648+(a-32<<23);i[63]=3347054592;for(let a=1;a<64;++a)a!==32&&(o[a]=1024);return{floatView:t,uint32View:e,baseTable:l,shiftTable:r,mantissaTable:c,exponentTable:i,offsetTable:o}}function $(n,t){const e=new Uint8Array(n);let l=0;for(;e[t.value+l]!=0;)l+=1;const r=new TextDecoder().decode(e.slice(t.value,t.value+l));return t.value=t.value+l+1,r}function P(n,t){const e=n.getInt32(t.value,!0);return t.value+=ln,e}function m(n,t){const e=n.getUint32(t.value,!0);return t.value+=ln,e}function Z(n,t){const e=n.getUint8(t.value);return t.value+=an,e}function B(n,t){const e=n.getUint16(t.value,!0);return t.value+=R,e}function cn(n,t){const e=n[t.value];return t.value+=an,e}function gn(n,t){let e;return"getBigInt64"in DataView.prototype?e=Number(n.getBigInt64(t.value,!0)):e=n.getUint32(t.value+4,!0)+Number(n.getUint32(t.value,!0)<<32),t.value+=xn,e}function b(n,t){const e=n.getFloat32(t.value,!0);return t.value+=X,e}function In(n,t){return On(B(n,t))}function On(n){const t=(n&31744)>>10,e=n&1023;return(n>>15?-1:1)*(t?t===31?e?NaN:1/0:Math.pow(2,t-15)*(1+e/1024):6103515625e-14*(e/1024))}function An(n){if(Math.abs(n)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");n=yn(n,-65504,65504),z.floatView[0]=n;const t=z.uint32View[0],e=t>>23&511;return z.baseTable[e]+((t&8388607)>>z.shiftTable[e])}function Pn(n,t){return An(b(n,t))}function Un(n,t,e){const l=new TextDecoder().decode(new Uint8Array(n).slice(t.value,t.value+e));return t.value=t.value+e,l}function _n(n,t){const e=P(n,t),l=m(n,t);return[e,l]}function mn(n,t){const e=m(n,t),l=m(n,t);return[e,l]}function Tn(n,t){const e=b(n,t),l=b(n,t);return[e,l]}function Nn(n,t){const e=b(n,t),l=b(n,t),r=b(n,t);return[e,l,r]}function Cn(n,t,e){const l=t.value,r=[];for(;t.value<l+e-1;){const c=$(n.buffer,t),i=P(n,t),o=Z(n,t);t.value+=3;const a=P(n,t),s=P(n,t);r.push({name:c,pixelType:i,pLinear:o,xSampling:a,ySampling:s})}return t.value+=1,r}function Rn(n,t){const e=b(n,t),l=b(n,t),r=b(n,t),c=b(n,t),i=b(n,t),o=b(n,t),a=b(n,t),s=b(n,t);return{redX:e,redY:l,greenX:r,greenY:c,blueX:i,blueY:o,whiteX:a,whiteY:s}}function Mn(n,t){return Z(n,t)}function Dn(n,t){const e=P(n,t),l=P(n,t),r=P(n,t),c=P(n,t);return{xMin:e,yMin:l,xMax:r,yMax:c}}function Ln(n,t){const e=Z(n,t);return K[e]}function kn(n,t,e,l){switch(e){case"string":case"stringvector":case"iccProfile":return Un(n.buffer,t,l);case"chlist":return Cn(n,t,l);case"chromaticities":return Rn(n,t);case"compression":return Mn(n,t);case"box2i":return Dn(n,t);case"lineOrder":return Ln(n,t);case"float":return b(n,t);case"v2f":return Tn(n,t);case"v3f":return Nn(n,t);case"int":return P(n,t);case"rational":return _n(n,t);case"timecode":return mn(n,t);case"preview":return t.value+=l,"skipped";default:t.value+=l;return}}function on(n){for(let t=1;t<n.length;t++){const e=n[t-1]+n[t]-128;n[t]=e}}function un(n,t){let e=0,l=Math.floor((n.length+1)/2),r=0;const c=n.length-1;for(;!(r>c||(t[r++]=n[e++],r>c));)t[r++]=n[l++]}const Fn=20000630;function zn(n,t){if(n.getUint32(0,!0)!=Fn)throw new Error("Incorrect OpenEXR format");const e=n.getUint8(4),l=n.getUint8(5),r={singleTile:!!(l&2),longName:!!(l&4),deepFormat:!!(l&8),multiPart:!!(l&16)};t.value=8;const c={};let i=!0;for(;i;){const o=$(n.buffer,t);if(!o)i=!1;else{const a=$(n.buffer,t),s=m(n,t),u=kn(n,t,a,s);u===void 0?Sn.Warn(`Unknown header attribute type ${a}'.`):c[o]=u}}if(l&-5)throw new Error("Unsupported file format");return{version:e,spec:r,...c}}const pn=16,Hn=1<<pn-1,nn=(1<<pn)-1;function Bn(n,t){let e=0;for(let r=0;r<H;++r)(r==0||n[r>>3]&1<<(r&7))&&(t[e++]=r);const l=e-1;for(;e<H;)t[e++]=0;return l}function Zn(n){for(let t=0;t<V;t++)n[t]={},n[t].len=0,n[t].lit=0,n[t].p=null}function tn(n,t,e,l,r){for(;e<n;)t=t<<8|cn(l,r),e+=8;return e-=n,{l:t>>e&(1<<n)-1,c:t,lc:e}}function J(n,t,e,l){return n=n<<8|cn(e,l),t+=8,{c:n,lc:t}}function Y(n,t,e,l,r,c,i,o,a){if(n==t){if(l<8){const f=J(e,l,r,c);e=f.c,l=f.lc}l-=8;let s=e>>l;if(s=new Uint8Array([s])[0],o.value+s>a)return null;const u=i[o.value-1];for(;s-- >0;)i[o.value++]=u}else if(o.value<a)i[o.value++]=n;else return null;return{c:e,lc:l}}const D=new Array(59);function Wn(n){for(let e=0;e<=58;++e)D[e]=0;for(let e=0;e<L;++e)D[n[e]]+=1;let t=0;for(let e=58;e>0;--e){const l=t+D[e]>>1;D[e]=t,t=l}for(let e=0;e<L;++e){const l=n[e];l>0&&(n[e]=l|D[l]++<<6)}}function Gn(n,t,e,l,r,c){const i=t;let o=0,a=0;for(;l<=r;l++){if(i.value-t.value>e)return;let s=tn(6,o,a,n,i);const u=s.l;if(o=s.c,a=s.lc,c[l]=u,u==sn){if(i.value-t.value>e)throw new Error("Error in HufUnpackEncTable");s=tn(8,o,a,n,i);let f=s.l+vn;if(o=s.c,a=s.lc,l+f>r+1)throw new Error("Error in HufUnpackEncTable");for(;f--;)c[l++]=0;l--}else if(u>=q){let f=u-q+2;if(l+f>r+1)throw new Error("Error in HufUnpackEncTable");for(;f--;)c[l++]=0;l--}}Wn(c)}function fn(n){return n&63}function hn(n){return n>>6}function Yn(n,t,e,l){for(;t<=e;t++){const r=hn(n[t]),c=fn(n[t]);if(r>>c)throw new Error("Invalid table entry");if(c>T){const i=l[r>>c-T];if(i.len)throw new Error("Invalid table entry");if(i.lit++,i.p){const o=i.p;i.p=new Array(i.lit);for(let a=0;a<i.lit-1;++a)i.p[a]=o[a]}else i.p=new Array(1);i.p[i.lit-1]=t}else if(c){let i=0;for(let o=1<<T-c;o>0;o--){const a=l[(r<<T-c)+i];if(a.len||a.p)throw new Error("Invalid table entry");a.len=c,a.lit=t,i++}}}return!0}function Xn(n,t,e,l,r,c,i,o,a){let s=0,u=0;const f=i,E=Math.trunc(l.value+(r+7)/8);for(;l.value<E;){let p=J(s,u,e,l);for(s=p.c,u=p.lc;u>=T;){const w=s>>u-T&d,y=t[w];if(y.len){u-=y.len;const h=Y(y.lit,c,s,u,e,l,o,a,f);h&&(s=h.c,u=h.lc)}else{if(!y.p)throw new Error("hufDecode issues");let h;for(h=0;h<y.lit;h++){const v=fn(n[y.p[h]]);for(;u<v&&l.value<E;)p=J(s,u,e,l),s=p.c,u=p.lc;if(u>=v&&hn(n[y.p[h]])==(s>>u-v&(1<<v)-1)){u-=v;const A=Y(y.p[h],c,s,u,e,l,o,a,f);A&&(s=A.c,u=A.lc);break}}if(h==y.lit)throw new Error("HufDecode issues")}}}const I=8-r&7;for(s>>=I,u-=I;u>0;){const p=t[s<<T-u&d];if(p.len){u-=p.len;const w=Y(p.lit,c,s,u,e,l,o,a,f);w&&(s=w.c,u=w.lc)}else throw new Error("HufDecode issues")}return!0}function qn(n,t,e,l,r,c){const i={value:0},o=e.value,a=m(t,e),s=m(t,e);e.value+=4;const u=m(t,e);if(e.value+=4,a<0||a>=L||s<0||s>=L)throw new Error("Wrong HUF_ENCSIZE");const f=new Array(L),E=new Array(V);Zn(E);const I=l-(e.value-o);if(Gn(n,e,I,a,s,f),u>8*(l-(e.value-o)))throw new Error("Wrong hufUncompress");Yn(f,a,s,E),Xn(f,E,n,e,u,s,c,r,i)}function Q(n){return n&65535}function en(n){const t=Q(n);return t>32767?t-65536:t}function N(n,t){const e=en(n),r=en(t),c=e+(r&1)+(r>>1),i=c,o=c-r;return{a:i,b:o}}function C(n,t){const e=Q(n),l=Q(t),r=e-(l>>1)&nn;return{a:l+r-Hn&nn,b:r}}function Kn(n,t,e,l,r,c,i){const o=i<16384,a=e>r?r:e;let s=1,u,f;for(;s<=a;)s<<=1;for(s>>=1,u=s,s>>=1;s>=1;){f=0;const E=f+c*(r-u),I=c*s,p=c*u,w=l*s,y=l*u;let h,v,A,k;for(;f<=E;f+=p){let x=f;const W=f+l*(e-u);for(;x<=W;x+=y){const O=x+w,g=x+I,F=g+w;if(o){let S=N(n[x+t],n[g+t]);h=S.a,A=S.b,S=N(n[O+t],n[F+t]),v=S.a,k=S.b,S=N(h,v),n[x+t]=S.a,n[O+t]=S.b,S=N(A,k),n[g+t]=S.a,n[F+t]=S.b}else{let S=C(n[x+t],n[g+t]);h=S.a,A=S.b,S=C(n[O+t],n[F+t]),v=S.a,k=S.b,S=C(h,v),n[x+t]=S.a,n[O+t]=S.b,S=C(A,k),n[g+t]=S.a,n[F+t]=S.b}}if(e&s){const O=x+I;let g;o?g=N(n[x+t],n[O+t]):g=C(n[x+t],n[O+t]),h=g.a,n[O+t]=g.b,n[x+t]=h}}if(r&s){let x=f;const W=f+l*(e-u);for(;x<=W;x+=y){const O=x+w;let g;o?g=N(n[x+t],n[O+t]):g=C(n[x+t],n[O+t]),h=g.a,n[O+t]=g.b,n[x+t]=h}}u=s,s>>=1}return f}function $n(n,t,e){for(let l=0;l<e;++l)t[l]=n[t[l]]}function Jn(n){let t=n.byteLength;const e=new Array;let l=0;const r=new DataView(n);for(;t>0;){const c=r.getInt8(l++);if(c<0){const i=-c;t-=i+1;for(let o=0;o<i;o++)e.push(r.getUint8(l++))}else{const i=c;t-=2;const o=r.getUint8(l++);for(let a=0;a<i+1;a++)e.push(o)}}return e}function wn(n){return new DataView(n.array.buffer,n.offset.value,n.size)}function Qn(n){const t=n.viewer.buffer.slice(n.offset.value,n.offset.value+n.size),e=new Uint8Array(Jn(t)),l=new Uint8Array(e.length);return on(e),un(e,l),new DataView(l.buffer)}function rn(n){const t=n.array.slice(n.offset.value,n.offset.value+n.size),e=fflate.unzlibSync(t),l=new Uint8Array(e.length);return on(e),un(e,l),new DataView(l.buffer)}function Vn(n){const t=n.array.slice(n.offset.value,n.offset.value+n.size),e=fflate.unzlibSync(t),l=n.lines*n.channels*n.width,r=n.type==1?new Uint16Array(l):new Uint32Array(l);let c=0,i=0;const o=new Array(4);for(let a=0;a<n.lines;a++)for(let s=0;s<n.channels;s++){let u=0;switch(n.type){case 1:o[0]=c,o[1]=o[0]+n.width,c=o[1]+n.width;for(let f=0;f<n.width;++f){const E=e[o[0]++]<<8|e[o[1]++];u+=E,r[i]=u,i++}break;case 2:o[0]=c,o[1]=o[0]+n.width,o[2]=o[1]+n.width,c=o[2]+n.width;for(let f=0;f<n.width;++f){const E=e[o[0]++]<<24|e[o[1]++]<<16|e[o[2]++]<<8;u+=E,r[i]=u,i++}break}}return new DataView(r.buffer)}function jn(n){const t=n.viewer,e={value:n.offset.value},l=new Uint16Array(n.width*n.scanlineBlockSize*(n.channels*n.type)),r=new Uint8Array(j);let c=0;const i=new Array(n.channels);for(let p=0;p<n.channels;p++)i[p]={},i[p].start=c,i[p].end=i[p].start,i[p].nx=n.width,i[p].ny=n.lines,i[p].size=n.type,c+=i[p].nx*i[p].ny*i[p].size;const o=B(t,e),a=B(t,e);if(a>=j)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(o<=a)for(let p=0;p<a-o+1;p++)r[p+o]=Z(t,e);const s=new Uint16Array(H),u=Bn(r,s),f=m(t,e);qn(n.array,t,e,f,l,c);for(let p=0;p<n.channels;++p){const w=i[p];for(let y=0;y<i[p].size;++y)Kn(l,w.start+y,w.nx,w.size,w.ny,w.nx*w.size,u)}$n(s,l,c);let E=0;const I=new Uint8Array(l.buffer.byteLength);for(let p=0;p<n.lines;p++)for(let w=0;w<n.channels;w++){const y=i[w],h=y.nx*y.size,v=new Uint8Array(l.buffer,y.end*R,h*R);I.set(v,E),E+=h*R,y.end+=h}return new DataView(I.buffer)}var _;(function(n){n[n.Float=0]="Float",n[n.HalfFloat=1]="HalfFloat"})(_||(_={}));class M{}M.DefaultOutputType=_.HalfFloat;M.FFLATEUrl="https://unpkg.com/fflate@0.8.2";async function dn(n,t,e,l){const r={size:0,viewer:t,array:new Uint8Array(t.buffer),offset:e,width:n.dataWindow.xMax-n.dataWindow.xMin+1,height:n.dataWindow.yMax-n.dataWindow.yMin+1,channels:n.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(n.compression){case U.NO_COMPRESSION:r.lines=1,r.uncompress=wn;break;case U.RLE_COMPRESSION:r.lines=1,r.uncompress=Qn;break;case U.ZIPS_COMPRESSION:r.lines=1,r.uncompress=rn,await G.LoadScriptAsync(M.FFLATEUrl);break;case U.ZIP_COMPRESSION:r.lines=16,r.uncompress=rn,await G.LoadScriptAsync(M.FFLATEUrl);break;case U.PIZ_COMPRESSION:r.lines=32,r.uncompress=jn;break;case U.PXR24_COMPRESSION:r.lines=16,r.uncompress=Vn,await G.LoadScriptAsync(M.FFLATEUrl);break;default:throw new Error(U[n.compression]+" is unsupported")}r.scanlineBlockSize=r.lines;const c={};for(const s of n.channels)switch(s.name){case"Y":case"R":case"G":case"B":case"A":c[s.name]=!0,r.type=s.pixelType}let i=!1;if(c.R&&c.G&&c.B)i=!c.A,r.outputChannels=4,r.decodeChannels={R:0,G:1,B:2,A:3};else if(c.Y)r.outputChannels=1,r.decodeChannels={Y:0};else throw new Error("EXRLoader.parse: file contains unsupported data channels.");if(r.type===1)switch(l){case _.Float:r.getter=In,r.inputSize=R;break;case _.HalfFloat:r.getter=B,r.inputSize=R;break}else if(r.type===2)switch(l){case _.Float:r.getter=b,r.inputSize=X;break;case _.HalfFloat:r.getter=Pn,r.inputSize=X}else throw new Error("Unsupported pixelType "+r.type+" for "+n.compression);r.blockCount=r.height/r.scanlineBlockSize;for(let s=0;s<r.blockCount;s++)gn(t,e);const o=r.width*r.height*r.outputChannels;switch(l){case _.Float:r.byteArray=new Float32Array(o),r.textureType=1,i&&r.byteArray.fill(1,0,o);break;case _.HalfFloat:r.byteArray=new Uint16Array(o),r.textureType=2,i&&r.byteArray.fill(15360,0,o);break;default:throw new Error("Unsupported type: "+l)}let a=0;for(const s of n.channels)r.decodeChannels[s.name]!==void 0&&(r.channelLineOffsets[s.name]=a*r.width),a+=s.pixelType*2;return r.bytesPerLine=r.width*a,r.outLineWidth=r.width*r.outputChannels,n.lineOrder==="INCREASING_Y"?r.scanOrder=s=>s:r.scanOrder=s=>r.height-1-s,r.outputChannels==4?(r.format=5,r.linearSpace=!0):(r.format=6,r.linearSpace=!1),r}function nt(n,t,e,l){const r={value:0};for(let c=0;c<n.height/n.scanlineBlockSize;c++){const i=P(e,l)-t.dataWindow.yMin;n.size=m(e,l),n.lines=i+n.scanlineBlockSize>n.height?n.height-i:n.scanlineBlockSize;const a=n.size<n.lines*n.bytesPerLine&&n.uncompress?n.uncompress(n):wn(n);l.value+=n.size;for(let s=0;s<n.scanlineBlockSize;s++){const u=c*n.scanlineBlockSize,f=s+n.scanOrder(u);if(f>=n.height)continue;const E=s*n.bytesPerLine,I=(n.height-1-f)*n.outLineWidth;for(let p=0;p<n.channels;p++){const w=t.channels[p].name,y=n.channelLineOffsets[w],h=n.decodeChannels[w];if(h!==void 0){r.value=E+y;for(let v=0;v<n.width;v++){const A=I+v*n.outputChannels+h;n.byteArray&&(n.byteArray[A]=n.getter(a,r))}}}}}}class tt{constructor(){this.supportCascades=!1}loadCubeData(t,e,l,r,c){throw".exr not supported in Cube."}async loadData(t,e,l){const r=new DataView(t.buffer),c={value:0},i=zn(r,c),o=await dn(i,r,c,M.DefaultOutputType);nt(o,i,r,c);const a=i.dataWindow.xMax-i.dataWindow.xMin+1,s=i.dataWindow.yMax-i.dataWindow.yMin+1;l(a,s,e.generateMipMaps,!1,()=>{const u=e.getEngine();e.format=i.format,e.type=o.textureType,e.invertY=!1,e._gammaSpace=!i.linearSpace,o.byteArray&&u._uploadDataToTextureDirectly(e,o.byteArray,0,0,void 0,!0)})}}const rt=Object.freeze(Object.defineProperty({__proto__:null,_ExrTextureLoader:tt},Symbol.toStringTag,{value:"Module"}));export{$n as A,U as C,Pn as D,_ as E,zn as G,qn as H,un as I,In as P,Bn as R,nt as S,jn as U,Kn as W,tt as _,dn as a,Jn as b,M as c,b as d,P as e,gn as f,$ as g,B as h,m as i,Z as j,cn as k,kn as l,on as m,Vn as n,wn as o,Qn as p,rn as q,rt as r};
