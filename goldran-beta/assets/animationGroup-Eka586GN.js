import{O as c,E as v,T as A,A as y}from"./Screen-Bl-8DfGB.js";import"./index-DzLpNkGY.js";class O{getClassName(){return"TargetedAnimation"}serialize(){const t={};return t.animation=this.animation.serialize(),t.targetId=this.target.id,t}}class f{get mask(){return this._mask}set mask(t){this._mask!==t&&(this._mask=t,this.syncWithMask(!0))}syncWithMask(t=!1){if(!this.mask&&!t){this._numActiveAnimatables=this._targetedAnimations.length;return}this._numActiveAnimatables=0;for(let e=0;e<this._animatables.length;++e){const i=this._animatables[e];!this.mask||this.mask.disabled||this.mask.retainsTarget(i.target.name)?(this._numActiveAnimatables++,i.paused&&i.restart()):i.paused||i.pause()}}removeUnmaskedAnimations(){if(!(!this.mask||this.mask.disabled)){for(let t=0;t<this._animatables.length;++t){const e=this._animatables[t];this.mask.retainsTarget(e.target.name)||(e.stop(),this._animatables.splice(t,1),--t)}for(let t=0;t<this._targetedAnimations.length;t++){const e=this._targetedAnimations[t];this.mask.retainsTarget(e.target.name)||(this._targetedAnimations.splice(t,1),--t)}}}get from(){return this._from}set from(t){if(this._from!==t){this._from=t;for(let e=0;e<this._animatables.length;e++){const i=this._animatables[e];i.fromFrame=this._from}}}get to(){return this._to}set to(t){if(this._to!==t){this._to=t;for(let e=0;e<this._animatables.length;e++){const i=this._animatables[e];i.toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(t){if(this._speedRatio!==t){this._speedRatio=t;for(let e=0;e<this._animatables.length;e++){const i=this._animatables[e];i.speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(t){if(this._loopAnimation!==t){this._loopAnimation=t;for(let e=0;e<this._animatables.length;e++){const i=this._animatables[e];i.loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(t){if(this._isAdditive!==t){this._isAdditive=t;for(let e=0;e<this._animatables.length;e++){const i=this._animatables[e];i.isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(t){this._weight!==t&&(this._weight=t,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(t){if(this._playOrder!==t&&(this._playOrder=t,this._animatables.length>0)){for(let e=0;e<this._animatables.length;e++)this._animatables[e].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(t){if(this._enableBlending!==t&&(this._enableBlending=t,t!==null))for(let e=0;e<this._targetedAnimations.length;++e)this._targetedAnimations[e].animation.enableBlending=t}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(t){if(this._blendingSpeed!==t&&(this._blendingSpeed=t,t!==null))for(let e=0;e<this._targetedAnimations.length;++e)this._targetedAnimations[e].animation.blendingSpeed=t}getLength(t,e){t=t??this._from,e=e??this._to;const i=this.targetedAnimations[0].animation.framePerSecond*this._speedRatio;return(e-t)/i}static MergeAnimationGroups(t,e=!0,i=!1,n){if(t.length===0)return null;n=n??t[0].weight;let a=Number.MAX_VALUE,s=-Number.MAX_VALUE;if(i)for(const o of t)o.from<a&&(a=o.from),o.to>s&&(s=o.to);const r=new f(t[0].name+"_merged",t[0]._scene,n);for(const o of t){i&&o.normalize(a,s);for(const l of o.targetedAnimations)r.addTargetedAnimation(l.animation,l.target);e&&o.dispose()}return r}constructor(t,e=null,i=-1,n=0){this.name=t,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new c,this.onAnimationLoopObservable=new c,this.onAnimationGroupLoopObservable=new c,this.onAnimationGroupEndObservable=new c,this.onAnimationGroupPauseObservable=new c,this.onAnimationGroupPlayObservable=new c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=e||v.LastCreatedScene,this._weight=i,this._playOrder=n,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(t,e){const i=new O;i.animation=t,i.target=e;const n=t.getKeys();return this._from>n[0].frame&&(this._from=n[0].frame),this._to<n[n.length-1].frame&&(this._to=n[n.length-1].frame),this._enableBlending!==null&&(t.enableBlending=this._enableBlending),this._blendingSpeed!==null&&(t.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(i),this._shouldStart=!0,i}removeTargetedAnimation(t){for(let e=this._targetedAnimations.length-1;e>-1;e--)this._targetedAnimations[e].animation===t&&this._targetedAnimations.splice(e,1)}normalize(t=null,e=null){t==null&&(t=this._from),e==null&&(e=this._to);for(let i=0;i<this._targetedAnimations.length;i++){const a=this._targetedAnimations[i].animation.getKeys(),s=a[0],r=a[a.length-1];if(s.frame>t){const o={frame:t,value:s.value,inTangent:s.inTangent,outTangent:s.outTangent,interpolation:s.interpolation};a.splice(0,0,o)}if(r.frame<e){const o={frame:e,value:r.value,inTangent:r.inTangent,outTangent:r.outTangent,interpolation:r.interpolation};a.push(o)}}return this._from=t,this._to=e,this}_processLoop(t,e,i){t.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(e),!this._animationLoopFlags[i]&&(this._animationLoopFlags[i]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(t=!1,e=1,i,n,a){if(this._isStarted||this._targetedAnimations.length===0)return this;this._loopAnimation=t,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let s=0;s<this._targetedAnimations.length;s++){const r=this._targetedAnimations[s],o=this._scene.beginDirectAnimation(r.target,[r.animation],i!==void 0?i:this._from,n!==void 0?n:this._to,t,e,void 0,void 0,a!==void 0?a:this._isAdditive);o.weight=this._weight,o.playOrder=this._playOrder,o.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(r),this._checkAnimationGroupEnded(o)},this._processLoop(o,r,s),this._animatables.push(o)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=e,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let t=0;t<this._animatables.length;t++)this._animatables[t].pause();return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(t){return this.isStarted&&this._animatables.length&&!this._shouldStart?(t!==void 0&&(this.loopAnimation=t),this.restart()):(this.stop(),this.start(t,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let t=0;t<this._animatables.length;t++)this._animatables[t].reset();return this}restart(){if(!this._isStarted)return this;for(let t=0;t<this._animatables.length;t++)this._animatables[t].restart();return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(t=!1){if(!this._isStarted)return this;const e=this._animatables.slice();for(let n=0;n<e.length;n++)e[n].stop(void 0,void 0,!0,t);let i=0;for(let n=0;n<this._scene._activeAnimatables.length;n++){const a=this._scene._activeAnimatables[n];a._runtimeAnimations.length>0?this._scene._activeAnimatables[i++]=a:t&&this._checkAnimationGroupEnded(a,t)}return this._scene._activeAnimatables.length=i,this._isStarted=!1,this}setWeightForAllAnimatables(t){for(let e=0;e<this._animatables.length;e++){const i=this._animatables[e];i.weight=t}return this}syncAllAnimationsWith(t){for(let e=0;e<this._animatables.length;e++)this._animatables[e].syncWith(t);return this}goToFrame(t,e=!1){if(!this._isStarted)return this;for(let i=0;i<this._animatables.length;i++)this._animatables[i].goToFrame(t,e);return this}getCurrentFrame(){var t;return((t=this.animatables[0])==null?void 0:t.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const t=this._scene.animationGroups.indexOf(this);if(t>-1&&this._scene.animationGroups.splice(t,1),this._parentContainer){const e=this._parentContainer.animationGroups.indexOf(this);e>-1&&this._parentContainer.animationGroups.splice(e,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(t,e=!1){const i=this._animatables.indexOf(t);i>-1&&this._animatables.splice(i,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,e||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(t,e,i=!1){const n=new f(t||this.name,this._scene,this._weight,this._playOrder);n._from=this.from,n._to=this.to,n._speedRatio=this.speedRatio,n._loopAnimation=this.loopAnimation,n._isAdditive=this.isAdditive,n._enableBlending=this.enableBlending,n._blendingSpeed=this.blendingSpeed,n.metadata=this.metadata,n.mask=this.mask;for(const a of this._targetedAnimations)n.addTargetedAnimation(i?a.animation.clone():a.animation,e?e(a.target):a.target);return n}serialize(){const t={};t.name=this.name,t.from=this.from,t.to=this.to,t.speedRatio=this.speedRatio,t.loopAnimation=this.loopAnimation,t.isAdditive=this.isAdditive,t.weight=this.weight,t.playOrder=this.playOrder,t.enableBlending=this.enableBlending,t.blendingSpeed=this.blendingSpeed,t.targetedAnimations=[];for(let e=0;e<this.targetedAnimations.length;e++){const i=this.targetedAnimations[e];t.targetedAnimations[e]=i.serialize()}return A&&A.HasTags(this)&&(t.tags=A.GetTags(this)),this.metadata&&(t.metadata=this.metadata),t}static Parse(t,e){const i=new f(t.name,e,t.weight,t.playOrder);for(let n=0;n<t.targetedAnimations.length;n++){const a=t.targetedAnimations[n],s=y.Parse(a.animation),r=a.targetId;if(a.animation.property==="influence"){const o=e.getMorphTargetById(r);o&&i.addTargetedAnimation(s,o)}else{const o=e.getNodeById(r);o!=null&&i.addTargetedAnimation(s,o)}}return A&&A.AddTagsTo(i,t.tags),t.from!==null&&t.to!==null&&i.normalize(t.from,t.to),t.speedRatio!==void 0&&(i._speedRatio=t.speedRatio),t.loopAnimation!==void 0&&(i._loopAnimation=t.loopAnimation),t.isAdditive!==void 0&&(i._isAdditive=t.isAdditive),t.weight!==void 0&&(i._weight=t.weight),t.playOrder!==void 0&&(i._playOrder=t.playOrder),t.enableBlending!==void 0&&(i._enableBlending=t.enableBlending),t.blendingSpeed!==void 0&&(i._blendingSpeed=t.blendingSpeed),t.metadata!==void 0&&(i.metadata=t.metadata),i}static MakeAnimationAdditive(t,e,i,n=!1,a){let s;typeof e=="object"?s=e:s={referenceFrame:e,range:i,cloneOriginalAnimationGroup:n,clonedAnimationName:a};let r=t;s.cloneOriginalAnimationGroup&&(r=t.clone(s.clonedAnimationGroupName||r.name));const o=r.targetedAnimations;for(let l=0;l<o.length;l++){const m=o[l];m.animation=y.MakeAnimationAdditive(m.animation,s)}if(r.isAdditive=!0,s.clipKeys){let l=Number.MAX_VALUE,m=-Number.MAX_VALUE;const _=r.targetedAnimations;for(let b=0;b<_.length;b++){const h=_[b].animation.getKeys();l>h[0].frame&&(l=h[0].frame),m<h[h.length-1].frame&&(m=h[h.length-1].frame)}r._from=l,r._to=m}return r}static ClipKeys(t,e,i,n,a){const s=t.clone(n||t.name);return f.ClipKeysInPlace(s,e,i,a)}static ClipKeysInPlace(t,e,i,n){return f.ClipInPlace(t,e,i,n,!1)}static ClipFrames(t,e,i,n,a){const s=t.clone(n||t.name);return f.ClipFramesInPlace(s,e,i,a)}static ClipFramesInPlace(t,e,i,n){return f.ClipInPlace(t,e,i,n,!0)}static ClipInPlace(t,e,i,n,a=!1){let s=Number.MAX_VALUE,r=-Number.MAX_VALUE;const o=t.targetedAnimations;for(let l=0;l<o.length;l++){const m=o[l],_=n?m.animation:m.animation.clone();a&&(_.createKeyForFrame(e),_.createKeyForFrame(i));const b=_.getKeys(),d=[];let u=Number.MAX_VALUE;for(let h=0;h<b.length;h++){const g=b[h];if(!a&&h>=e&&h<=i||a&&g.frame>=e&&g.frame<=i){const p={frame:g.frame,value:g.value.clone?g.value.clone():g.value,inTangent:g.inTangent,outTangent:g.outTangent,interpolation:g.interpolation,lockedTangent:g.lockedTangent};u===Number.MAX_VALUE&&(u=p.frame),p.frame-=u,d.push(p)}}if(d.length===0){o.splice(l,1),l--;continue}s>d[0].frame&&(s=d[0].frame),r<d[d.length-1].frame&&(r=d[d.length-1].frame),_.setKeys(d,!0),m.animation=_}return t._from=s,t._to=r,t}getClassName(){return"AnimationGroup"}toString(t){let e="Name: "+this.name;return e+=", type: "+this.getClassName(),t&&(e+=", from: "+this._from,e+=", to: "+this._to,e+=", isStarted: "+this._isStarted,e+=", speedRatio: "+this._speedRatio,e+=", targetedAnimations length: "+this._targetedAnimations.length,e+=", animatables length: "+this._animatables),e}}export{f as AnimationGroup,O as TargetedAnimation};
